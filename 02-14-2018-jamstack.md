# JAMstack PWA - Up and Running with Gatsby.js, Firebase, and Netlify Pt. 1

In this two part tutorial I'll show you how to get up and running with a progressive web application (PWA) that makes use of a powerful web architecture pattern called the JAMstack. We'll start out initializing the project with linting and code formatting, building out the UI of our application, and finally we'll deploy it to the web.

## What is JAMstack?

As defined on [jamstack.org](https://jamstack.org/):

> `JAMstack`: noun \’jam-stak’\
> Modern web development architecture based on client-side JavaScript, reusable APIs, and prebuilt Markup.

Paraphrased: JAMstack is a way of architecting your web applications with three key principals:

1. The client-side javascript handles all data fetching.
2. The APIs the client(s) depend on, such as any databases, authentication services, asset CDNs, etc., are abstracted into CORS enabled microservices to be accessable from the client-side javascript.
3. Markup is prerendered at _build-time_, though not required, usually done with a static site generator.

## Cool story. But why?

### Performance

With the markup being rendered at build-time, there is no server runtime to generate the markup. The HTML files are already there ready to be sent over to the client. Granted the performance gains here aren't groundbreaking as most web server implementations utilize page caching, but any gains to time to first byte is a plus.

### Cost

Again, since there's no server runetime and all that's being served are some static assets, the assets can be stored on and served from a CDN. Meaning costs to deploy your site are low and with some services like Netlify (which we'll cover later) can even be free.

### SEO

Search engines have an easier time crawling your website when markup is being served. This is not to say SPAs are not crawled by search engines, however, there are edge cases that make it difficult.

### Developer experience

With the backend services abstracted away into their own APIs, the front-end engineer has free reign over what tools, libraries, frameworks, and languages to utilzie on the front-end. There are no restriction on what preprocessed languages or build tools can be used as the case with some web frameworks. Personally, I think the tools the node.js community have developed are second to none when it comes to DX. Tools like Webpack have enabled things like [Hot Module Replacement](https://webpack.js.org/concepts/hot-module-replacement/]). I know and love the development workflow node.js projects have to offer and often find myself longing for those tools when working on projects with what I consider inferior development tooling.

## About the app we're building

We'll be building a simple polling application. Authenticated users will be able to create a poll with some options that they in turn can share with a generated link. Users visiting that link can then choose one of the options and have their selection reflected on the results in real time.

## Our Front-end Stack

* [Gatsby.js](https://www.gatsbyjs.org/): Gatsby makes use of React.js's server-side rendering capabilities to generate markup at build time. Though not covered in this tutorial, it also enables developers to fetch data from any data source and declaratively pull that data into their components using GraphQL so that the components can be hydrated with data at build time.
* [Firebase firestore](https://firebase.google.com/products/firestore/): A noSQL cloud database that exposes event listerners for real time updates whenever data changes via a super easy to use web SDK.
* [Firebase auth](https://firebase.google.com/products/auth/): To authenticate users via OAuth 2. Like firestore, has a web SDK that handles all of the nitty griddy details of OAuth2 authentication.
* [Netlify](https://www.netlify.com/): Netlify is a global CDN that makes continuous deployments as simple as a few clicks. Deploying with Netlify is as easy as it comes.
* [Styled-components](https://www.styled-components.com/): A react specific css-in-js solution.
* [Prettier](https://prettier.io/): An opinionated code formatter.
* [ESLint](https://eslint.org/): Javascript linting.

All tools used in this tutorial are free or have an incredibly genereous free tier, so feel free to follow along.

## Getting Started - Project Setup

Let's get started! Install `gatsby-cli` globally, then run `gatsby new polling-app` and initialize `git` inside the new directory.

> Gatsby.js requires node v4.0.0 plus, before continuing check your version of node by running `node -v`. I'd recommend installing, at least, the lastest version of Node LTS.

`npm install --global gatsby-cli && gatsby new polling-app && cd polling-app && git init`

> I won't be covering any git workflows in this tutorial, however, at the end of the tutorial we'll set up Netlify with git for continuous deployments.

Let's now set up eslint. I generally like to install [Airbnb's](https://www.npmjs.com/package/eslint-config-airbnb) eslint config, then just override the rules I don't like. Install airbnb's config and peer depedancies. If you're on Linux/OSX, just copy and paste this script into your terminal:

```
(
  export PKG=eslint-config-airbnb;
  npm info "$PKG@latest" peerDependencies --json | command sed 's/[\{\},]//g ; s/: /@/g' | xargs npm install --save-dev "$PKG@latest"
)
```

> If you're on windows, head over to Airbnb's eslint config repository linked above and there will be directions on how to get those dependancies installed.

Install other eslint peer-dependancies as well as prettier:

`npm install -D babel-eslint eslint-config-react eslint-config-prettier eslint-plugin-prettier prettier`

> -D specifies that these are development dependancies.

Add a `.eslintrc` file to the root of your project and paste in these rules. Anything you don't like, you can just override under `rules`.

```json
{
  "extends": ["airbnb", "prettier", "prettier/react"],
  "rules": {
    "react/jsx-filename-extension": [
      "error",
      { "extensions": [".js", ".jsx"] }
    ],
    "react/react-in-jsx-scope": 0,
    "react/require-default-props": 0,
    "no-shadow": 0,
    "consistent-return": 0,
    "no-console": 1,
    "no-case-declarations": 0,
    "import/prefer-default-export": 0
  },
  "plugins": ["prettier"],
  "settings": {
    "import/core-modules": ["react", "prop-types"]
  },
  "parser": "babel-eslint",
  "parserOptions": {
    "ecmaVersion": 2017,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "env": {
    "es6": true,
    "browser": true,
    "node": true
  }
}
```

Do the same for a `.prettierrc` file:

```json
{
  "printWidth": 80,
  "singleQuote": true,
  "trailingComma": "all",
  "write": "src/**/*.js",
  "jsxBracketSameLine": true
}
```

Since we're specifying our own prettier rules here, go to your `package.json` and remove the rules passed in as flags under `scripts.format`. By default, Prettier will check for a `.prettierrc` file in the root of the project and use those rules.

`"format": "prettier --write \"src/**/*.{js,jsx}\""`

While we're at it, let's add a script for eslint:

`"lint": "eslint **/*.{js,jsx} --quiet"`

> --quiet flag specifies that only errors are to be reported, not warnings.

> [Optional] For a better development experience, I'd suggest installing the plugins for your IDE/Code editor. [ESLint](https://eslint.org/docs/user-guide/integrations) and [Prettier](https://prettier.io/docs/en/editors.html).

## Gatsby Project Structure

Let's cover the directory structure generated by gatsby-cli.

* `src/pages/` is a required directory. `src/pages/index.js` corresponds to the root path of the website. So the component defined in `index.js` is rendered on `www.mysite.com/`. The only other file that has a predefined name is `404.js`. This page is rendered anytime a user navigates to a page that does not exist. All other files in this directory have their filenames corresponding to the site's path. `src/pages/page-2` can be found in [localhost:8000/page-2/](http://localhost:8000/page-2/). Nested paths can be created by adding a sub-directory inside `src/pages`. For example: `src/pages/polls/new` would be `www.mysite.com/polls/new`. In my opinion, this API is very intuitive and works great for most cases.
* `src/layouts/`: Though not required, files here have a specific purpose as defined by Gatsby. To keep things simple, we're only concerned with `src/layours/index.js`. This file is wrapped around _all_ page components inside `src/pages`. This would be the place to insert your Header and Footer components assuming all of your pages have a header and footer.
* `src/components/`: This is where you place your custom components and how you structure this directory is up to you. Technically, your components don't even have to be in the `src/components/` directory, but this is the usual convention.

## Gatsby Plugins

Gatsby has quite a bit of official and community plugins that make integrating many common tools or libraries a breeze. One of which is [gatsby-plugin-styled-components](https://www.gatsbyjs.org/packages/gatsby-plugin-styled-components/). Let's look into how to add a plugin to a Gatsby project.

Install gatsby-plugin-styled-components as well as styled-components:

`npm install gatsby-plugin-styled-components styled-components`

Open up `gatsby-config.js` in the root of your project as you can see we already have `gatsby-plugin-react-helmet` plugin being used added there by gatsby-cli's default project starter. Add `gatsby-plugin-styled-components` as another item in the `plugins` array.

> For these two particular plugins, order does not matter. However, be aware ther are some plugins that need be place before or after other plugins. Just whenever adding a plugin, be sure to read the documentation, otherwise you might get some unexpected behavior.

> Whenever adding plugins you may have to restart your development server

You can read more about Gatsby's plugins [here](https://www.gatsbyjs.org/docs/plugins/#plugins).

## Getting our hands dirty

Let's actually write some code! Go ahead and delete `src/pages/page-2.js` assuming your version of `gatsby-cli` generated that file, we won't be needing it. Also delete the `<Link>` component in `pages/index.js` as that pages no longer exists.

Next, let's modify the Header component a bit. Change the Header title from Gatsby to something creative and original - like "Polling App". Now let's move the inline styles to be instead handled by `styled-components`. Your Header file should now look like this:

```jsx
import React from 'react';
import Link from 'gatsby-link';
import styled from 'styled-components';
import PropTypes from 'prop-types';

const HeaderContainer = styled.header`
  ${props => props.backgroundColor};
  margin-bottom: 1.45rem;
`;

const HeaderWrapper = styled.div`
  margin: 0 auto;
  max-width: 960px;
  padding: 1.45rem 1.0875rem;
`;

const Heading1 = styled.h1`
  margin: 0;
`;

const StyledLink = styled(Link)`
  color: white;
  text-decoration: none;
`;

const BACKGROUND_COLOR = 'background-color: #20232a';

const Header = ({ backgroundColor }) => (
  <HeaderContainer backgroundColor={backgroundColor}>
    <HeaderWrapper>
      <Heading1>
        <StyledLink to="/">Polling App</StyledLink>
      </Heading1>
    </HeaderWrapper>
  </HeaderContainer>
);

Header.defaultProps = {
  backgroundColor: BACKGROUND_COLOR,
};

Header.propTypes = {
  backgroundColor: PropTypes.string,
};

export default Header;
```

A couple things to note here:

1. The weird opening and closing backticks (\`\`) after `styled`. These are [template literal's](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), just being used in a lesser known way. It enables front-end developers to use actual css property names as opposed to their camelCase counterparts required in javascript.
2. Because of this unusual use of template literals, most IDEs and code editors do not have built-in syntax highlighting for the css defined inside the template literal strings. [Here's a link](https://www.styled-components.com/docs/tooling#syntax-highlighting) where can check if your favorite editor has a syntax highlighting plugin for styled-components.
3. The `styled(Link)` component. This is a higher order function that passes the processed styles within the template literals to the wrapped component. This can work with any 3rd party component so long as the wrapped component passes `props.style` to a child DOM element.
4. `headerColor` being passed to the `HeaderContainer` styled-component. This is what makes styled-components really awesome. It allows you to pass in dynamic data to your components's styles giving you flexability with your styling that you otherwise wouldn't have

<!-- TODO: Do this later -->

Let's spruce up that boring header background-color! _(Shameless plug time)_ Head over to [www.grabient.com](https://www.grabient.com/) and grab yourself a gradient, be sure to untick `prefixes` as styled-components already handled all vendor prefixes for you.

Change
`const BACKGROUND_COLOR = 'background-color: #20232a'`

to

`const BACKGROUND_COLOR = 'background-image: linear-gradient(116deg, #08AEEA 0%, #2AF598 100%'`

_or you're favorite grabient :)_
